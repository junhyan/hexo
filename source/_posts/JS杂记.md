---
title: JS杂记
date: 2018-04-28
---
工作一直在忙碌着，做了一段时间的前端了，是时候做一些总结，看看书，记记笔记。
## 杂记
每个执行环境都有与之对应的变量对象，环境中定义的所有变量和函数都保存在这个变量对象中，但是在编码的时候是看不到这个变量对象的，当代码在一个环境中执行时候，会创建变量对象的一个作用域链，对于一个函数的作用域链，作用域链的最前是当前函数的变量对象 ---> 包含该函数的上层作用域变量对象  ---> n --> 全局作用域变量对象 ，with可以延长作用域链
if 和for 在js中没有作用域变量对象。   
垃圾回收机制包括：1 标记清除 2 引用计数
可以通过使用更少的内存来优化页面的的性能
Array
push 在数组尾部插入数据
pop 从数组尾部取出数据
shift 从数组头部取出数据
unshift 在数组头部插入数据
splice 可以实现删除，替换，和插入，参数，（起始位置，要删除的项数，后面是要插入的项）
indexOf lastIndexOf反向定位

引用类型， object， array ， date， regexp， function
数据属性
object.defineProperty(对象名，对象属性名，描述符对象)

访问器属性
不包数据值，但是包含一对getter和setter函数
eval传递字符串，导致性能损失

继承：
原型链方式实现继承（不足：原型链会共享，不能向父类型传递参数）
借用构造函数 ：使用superClass.call(this) 函数复用性不足
组合继承
原型式继承
寄生式继承
寄生组合式继承

闭包只能取得包含函数中的变量的最后的值

js中对后续相同的命名变量声明会视而不见

转载请注明: http://jhyan.me/2018/04/28/JS杂记/
